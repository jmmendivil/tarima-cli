#!/usr/bin/env node

var run = require('../lib'),
    path = require('path'),
    minimist = require('minimist'),
    spawn = require('child_process').spawn;

var $ = require('../lib/utils');

var cwd = process.cwd(),
    die = process.exit.bind(process),
    pkg = path.join(cwd, 'package.json'),
    bower = path.join(cwd, 'bower.json'),
    thisPkg = require(path.join(__dirname, '../package.json'));

var argv = minimist(process.argv.slice(2), {
  boolean: ['debug', 'force', 'watch', 'bundle', 'verbose', 'server', 'open'],
  string: ['ext', 'only', 'exclude', 'require', 'port', 'proxy', 'browser', 'globals', 'config'],
  alias: {
    c: 'config',
    v: 'version',
    V: 'verbose',
    r: 'require',
    x: 'exclude',
    b: 'bundle',
    d: 'debug',
    f: 'force',
    w: 'watch',
    i: 'only',
    e: 'ext',
    s: 'server',
    o: 'open',
    p: 'port',
    P: 'proxy',
    B: 'browser',
    G: 'globals'
  },
  '--': true
});

if (argv.help) {
  console.log('USAGE:\n  ' + Object.keys(thisPkg.bin)[0] + ' [SRC] [DEST] [OPTIONS]');
  console.log(function() {/*---
OPTIONS:
  -c, --config    Use configuration file
  -V, --verbose   Increase log information
  -r, --require   Load scripts at startup (e.g. -r some-module -r ./lib/hooks.js)
  -x, --exclude   Filter out sources using globs (e.g. -x test/broken -x .coffee)
                  Example patterns:
                    - *foo     -> !*foo
                    - .bar     -> !**\/*.bar
                    - x.y      -> !**\/x.y
                    - foo      -> !**\/foo/**
                    - foo/bar  -> !**\/foo\/bar/**
  -e, --ext       Configure automatic extensions (e.g. -e coffee:js -e jade:hbs:html)
                  This means ".coffee to .js" and ".jade and .hbs to .html" respectively
  -i, --only      Filter out non-matching sources using String.prototype.indexOf()
  -f, --debug     Enable compileDebug flag for some engines
  -f, --force     Compile all sources always
  -w, --watch     Enable file watching for all sources
  -b, --bundle    Enable script bundling via Browserify (styles, views, etc.)
  -s, --server    Enable web-server support via BrowserSync
                  You can configure this through `serverOptions`
  -o, --open      Enable to open your default (or configured) --browser
  -p, --port      Set a different port for BrowserSync (default: 3000)
  -P, --proxy     Enable proxying instead --server (e.g. -P localhost:8080)
  -B, --browser   Set a custom browser when --open is specified
  -G, --globals   Set custom values to inject on compiled scripts (e.g. -G FOO=BAR)
---*/}.toString().match(/---([\s\S]+)---/)[1].replace(/\\/g, ''));
  die(1);
}

if (argv.version) {
  console.log(thisPkg.name + ' v' + thisPkg.version);
  die(1);
}

var fixedSrc = argv._[0] || 'src',
    fixedDest = argv._[1] || 'build';

var defaultConfig = {
  cwd: cwd,
  src: path.join(cwd, fixedSrc),
  dest: path.join(cwd, fixedDest, 'dist'),
  cache: path.join(cwd, fixedDest, 'index.json'),
  force: argv.force,
  watch: argv.watch,
  bundle: argv.bundle,
  verbose: argv.verbose,
  require: argv.require,
  server: argv.server,
  open: argv.open,
  port: argv.port,
  proxy: argv.proxy,
  browser: argv.browser,
  filtered: [],
  extensions:{},
  compileOptions: {
    globals: {}
  }
};

[pkg, bower].forEach((file) => {
  if ($.isFile(file)) {
    $.merge(defaultConfig, $.readJSON(file).tarima || {});
  }
})

if ($.isFile(argv.config)) {
  $.merge(defaultConfig, $.readJSON(argv.config) || {});
}

function fixedArray(obj) {
  return !Array.isArray(obj) ? obj.split(',') : obj;
}

function fixedValue(string) {
  if (/^-?\d+(\.\d+)?$/.test(string)) {
    return parseFloat(string);
  }

  var values = {
    true: true,
    false: false
  };

  if (typeof values[string] !== 'undefined') {
    return values[string];
  }

  return string || null;
}

if (argv.ext) {
  fixedArray(argv.ext).forEach(function(ext) {
    fixedArray(ext).forEach(function(map) {
      var parts = map.split(':'),
          to = parts.pop();

      parts.forEach(function(key) {
        defaultConfig.extensions[key] = to;
      });
    });
  });
}

if (argv.only) {
  var test = fixedArray(argv.only);

  defaultConfig.filtered.push(function(value) {
    for (var key in test) {
      if (value.indexOf(test[key]) > -1) {
        return true;
      }
    }
  });
}

if (argv.exclude) {
  fixedArray(argv.exclude).forEach(function(skip) {
    if (skip.indexOf('*') > -1) {
      defaultConfig.filtered.push('!' + skip);
    } else if (skip.substr(0, 1) === '.') {
      defaultConfig.filtered.push('!**/*' + skip);
    } else if (skip.indexOf('.') > -1) {
      defaultConfig.filtered.push('!**/' + skip);
    } else {
      defaultConfig.filtered.push('!**/' + skip + '/**');
    }
  });
}

if (argv.globals) {
  fixedArray(argv.globals).forEach(function(value) {
    var parts = value.split('=');

    defaultConfig.compileOptions.globals[parts[0]] = fixedValue(parts[1]);
  });
}

defaultConfig.compileOptions.compileDebug = argv.debug;
defaultConfig.compileOptions.verboseDebug = argv.verbose;

var cmd = argv['--'],
    child;

function errLog(message) {
  process.stderr.write($.color.red(message) + '\n');
}

function infoLog(message) {
  process.stdout.write(message + '\n');
}

run(defaultConfig, function(err, result) {
  if (err) {
    errLog(err.message || err.toString());
  }

  var onError = this.emit.bind(null, 'error');

  var suffix = argv.watch ? $.style('\n{blackBright|# Waiting for changes...}') : '',
      status = (err || (err = result.err && result.err.length)) ? 'yellow' : 'cyan';

  if (!result.files.length) {
    infoLog($.style('{blackBright|# Without changes (%s)}', $.timeDiff(result.start)) + suffix);
  } else {
    infoLog($.style('{%s|# %s of %s file%s updated in %s}',
      status,
      result.ok.length,
      result.files.length,
      result.ok.length !== 1 ? 's' : '',
      $.timeDiff(result.start)) + suffix);
  }

  if (!argv.watch && err) {
    if (child) {
      child.kill();
    }

    die(1);
  }

  if (cmd.length && result.files.length && !err) {
    if (child) {
      child.kill();
    }

    var start = new Date();

    infoLog($.style('{cyan|# %s} %s', cmd[0], cmd.slice(1).join(' ')));

    child = spawn(cmd[0], cmd.slice(1));

    child.stdout.pipe(process.stdout);

    var errors = [];

    child.stderr.on('data', function(data) {
      var line = data.toString().trim();

      if (line) {
        errors.push(line);
      }
    });

    child.on('close', function(exitCode) {
      infoLog($.style('{%s|# %s} done in %s', exitCode || errors.length ? 'red' : 'cyan', cmd[0], $.timeDiff(start)));

      if (errors.length) {
        errLog('\n' + errors.join('\n'));
        onError(errors.join('\n'));

        // TODO: halt on this?
        // exitCode = exitCode || !!(errLog.length);
      }

      if (exitCode && !argv.watch) {
        die(exitCode);
      }
    });
  }
});
