#!/usr/bin/env node

var path = require('path'),
    minimist = require('minimist');

var argv = minimist(process.argv.slice(2), {
  boolean: ['debug', 'force', 'quiet', 'watch', 'verbose', 'server', 'open'],
  string: ['map', 'only', 'exclude', 'require', 'port', 'proxy', 'browser', 'globals', 'config'],
  alias: {
    q: 'quiet',
    c: 'config',
    v: 'version',
    V: 'verbose',
    r: 'require',
    x: 'exclude',
    d: 'debug',
    f: 'force',
    w: 'watch',
    y: 'only',
    m: 'map',
    s: 'server',
    o: 'open',
    p: 'port',
    P: 'proxy',
    B: 'browser',
    G: 'globals'
  },
  '--': true
});

// common helpers
var $ = require('../lib/utils');

var logger = require('../lib/logger');

var die = process.exit.bind(process);

var thisPkg = require(path.join(__dirname, '../package.json'));

if (argv.help) {
  logger.writeln('USAGE:\n  ' + Object.keys(thisPkg.bin)[0] + ' [SRC] [DEST] [OPTIONS]');
  logger.writeln(function() {/*---
OPTIONS:
  -q, --quiet     Disable all logs
  -c, --config    Use configuration file
  -V, --verbose   Increase log information
  -r, --require   Load scripts at startup (e.g. -r some-module -r ./lib/hooks.js)
  -x, --exclude   Filter out sources using globs (e.g. -x test/broken -x .coffee)
                  Example patterns:
                    - *foo     -> !*foo
                    - .bar     -> !**\/*.bar
                    - x.y      -> !**\/x.y
                    - foo      -> !**\/foo/**
                    - foo/bar  -> !**\/foo\/bar/**
  -m, --map       Configure extensions mapping (e.g. -m coffee:js -m jade:hbs:html)
                  This means ".coffee to .js" and ".jade and .hbs to .html" respectively
  -y, --only      Filter out non-matching sources using String.prototype.indexOf()
  -d, --debug     Enable compileDebug flag for some engines
  -f, --force     Compile all sources always
  -w, --watch     Enable file watching for all sources
  -s, --server    Enable web-server support via BrowserSync
                  You can configure this through `serverOptions`
  -o, --open      Enable to open your default (or configured) --browser
  -p, --port      Set a different port for BrowserSync (default: 3000)
  -P, --proxy     Enable proxying instead --server (e.g. -P localhost:8080)
  -B, --browser   Set a custom browser when --open is specified
  -G, --globals   Set custom values to inject on compiled scripts (e.g. -G FOO=BAR)
---*/}.toString().match(/---([\s\S]+)---/)[1].replace(/\\/g, ''));
  die(1);
}

if (argv.version) {
  logger.printf('{cyan|⚡ %s v%s}\n', thisPkg.name, thisPkg.version);
  die(1);
}

if (!argv.quiet) {
  logger.setLevel(argv.verbose ? 'verbose' : argv.debug ? 'debug' : 'info');
}

var run = require('../lib'),
    spawn = require('child_process').spawn;

var cwd = process.cwd(),
    pkg = path.join(cwd, 'package.json'),
    bower = path.join(cwd, 'bower.json');

var fixedSrc = argv._[0] || 'src',
    fixedDest = argv._[1] || 'build';

var defaultConfig = {
  cwd: cwd,
  src: path.join(cwd, fixedSrc),
  dest: path.join(cwd, fixedDest, 'dist'),
  cache: path.join(cwd, fixedDest, 'index.json'),
  filter: [],
  force: argv.force,
  watch: argv.watch,
  require: argv.require,
  server: argv.server,
  open: argv.open,
  port: argv.port,
  proxy: argv.proxy,
  browser: argv.browser,
  extensions: {},
  notifications: {
    title: thisPkg.name,
    okIcon: path.join(__dirname, 'ok.png'),
    errIcon: path.join(__dirname, 'err.png')
  },
  compileOptions: {
    globals: {}
  }
};

[pkg, bower].forEach(function (file) {
  if ($.isFile(file)) {
    $.merge(defaultConfig, $.readJSON(file).tarima || {});
  }
});

if ($.isFile(argv.config)) {
  $.merge(defaultConfig, $.readJSON(argv.config) || {});
}

function fixedArray(obj) {
  return !Array.isArray(obj) ? obj.split(',') : obj;
}

function fixedValue(string) {
  if (/^-?\d+(\.\d+)?$/.test(string)) {
    return parseFloat(string);
  }

  var values = {
    true: true,
    false: false
  };

  if (typeof values[string] !== 'undefined') {
    return values[string];
  }

  return string || null;
}

if (argv.map) {
  fixedArray(argv.map).forEach(function(ext) {
    fixedArray(ext).forEach(function(map) {
      var parts = map.split(':'),
          to = parts.pop();

      parts.forEach(function(key) {
        defaultConfig.extensions[key] = to;
      });
    });
  });
}

if (argv.only) {
  var test = fixedArray(argv.only);

  defaultConfig.filter.push(function(value) {
    value = path.relative(defaultConfig.src, value);

    for (var key in test) {
      if (value.indexOf(test[key]) > -1) {
        return true;
      }
    }
  });
}

if (argv.exclude) {
  fixedArray(argv.exclude).forEach(function(skip) {
    if (skip.indexOf('*') > -1) {
      defaultConfig.filter.push('!' + skip);
    } else if (skip.substr(0, 1) === '.') {
      defaultConfig.filter.push('!**/*' + skip);
    } else if (skip.indexOf('.') > -1) {
      defaultConfig.filter.push('!**/' + skip);
    } else {
      defaultConfig.filter.push('!**/' + skip + '/**');
    }
  });
}

if (argv.globals) {
  fixedArray(argv.globals).forEach(function(value) {
    var parts = value.split('=');

    defaultConfig.compileOptions.globals[parts[0]] = fixedValue(parts[1]);
  });
}

defaultConfig.compileOptions.compileDebug = argv.debug;
defaultConfig.compileOptions.verboseDebug = argv.verbose;

var cmd = argv['--'],
    child;

function errLog(message) {
  process.stderr.write($.color.red(message) + '\n');
}

function infoFiles(err, result) {
  if (argv.watch || argv.server) {
    if (!argv.watch) {
      logger.printf('{pending.blackBright|Nothing to watch... [press CTRL-C to quit]}\n');
    }

    // TODO: improve this
    var msg,
        max = 3,
        len = result.changedFiles.length;

    var suffix = len > max ? ('(' + (len - max) + ' file' + ((len - max) !== 1 ? 's' : '') + ' more)') : '';

    var changes = result.changedFiles.slice(0, max).map(function(file) {
      return path.relative(cwd, file.dest);
    });

    var prelude = changes.join('\n') + (suffix ? '\n' + suffix : '') + '\n— ';

    if (err) {
      msg = prelude + err.message || err.description || err.toString();
    }

    if (!err && result.changedFiles.length) {
      msg = prelude + result.changedFiles.length + ' file' +
        (result.changedFiles.length !== 1 ? 's' : '') + ' in ' + result.elapsed;
    }

    if (msg) {
      $.notify(msg,
        defaultConfig.notifications.title,
        defaultConfig.notifications[err ? 'errIcon' : 'okIcon']);
    }

    return;
  }

  if (!result.files.length) {
    logger.printf('{info.blackBright|Without changes (%s)}\n', $.timeDiff(result.start));
  }
}

function exec(onError) {
  function start() {
    var start = new Date();

    logger.writeln($.color.cyan(cmd[0]) + ' ' + cmd.slice(1).join(' '));

    child = spawn(cmd[0], cmd.slice(1), { detached: true });

    child.stdout.pipe(process.stdout);

    var errors = [];

    child.stderr.on('data', function(data) {
      var line = data.toString().trim();

      if (line) {
        errors.push(line);
      }
    });

    child.on('close', function(exitCode) {
      var end = $.timeDiff(start);

      var message = '`' + cmd.join(' ') + '`\n— ',
          icon = defaultConfig.notifications.okIcon;

      if (exitCode || errors.length) {
        icon = defaultConfig.notifications.errIcon;
        message += 'Error';
      } else {
        message += 'Done in ' + end;
      }

      $.notify(message, defaultConfig.notifications.title, icon);

      if (errors.length) {
        errLog(errors.join('\n'));
        onError(errors.join('\n'));
      }

      logger.writeln($.color[exitCode || errors.length  ? 'red' : 'cyan'](cmd[0]) + ' done in ' + end);

      if (exitCode && !argv.watch) {
        die(exitCode);
      }
    });
  }

  if (child) {
    child.on('close', start)
    child.kill('SIGINT');
  } else {
    start();
  }
}

logger.INFO('Processing files from `%s`\n', path.relative(cwd, defaultConfig.src));
logger.INFO('Compiling to `%s`\n', path.relative(cwd, defaultConfig.dest));

process.on('SIGINT', function() {
  if (child) {
    logger.writeln('\r' + $.color.cyan(cmd[0]) + ' done (SIGINT)');
    child.kill('SIGINT');
  }

  process.exit();
});

run(defaultConfig, function(err, result) {
  if (err) {
    errLog(err.message || err.toString());
  }

  if (result) {
    infoFiles(err, result);
  }

  if (!argv.watch && err) {
    if (child) {
      child.kill();
    }

    die(1);
  }

  if (cmd.length && !err) {
    exec(this.emit.bind(null, 'error'));
  }
});
