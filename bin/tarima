#!/usr/bin/env node

var run = require('../lib'),
    path = require('path'),
    minimist = require('minimist'),
    spawn = require('child_process').spawn;

var $ = require('../lib/utils');

var cwd = process.cwd(),
    die = process.exit.bind(process),
    pkg = path.join(cwd, 'package.json');

var argv = minimist(process.argv.slice(2), {
  boolean: ['force', 'watch', 'bundle', 'verbose', 'server', 'open'],
  string: ['only', 'exclude', 'require', 'port', 'proxy', 'browser', 'globals'],
  alias: {
    V: 'verbose',
    r: 'require',
    x: 'exclude',
    b: 'bundle',
    f: 'force',
    w: 'watch',
    i: 'only',
    s: 'server',
    o: 'open',
    p: 'port',
    P: 'proxy',
    B: 'browser',
    g: 'globals'
  },
  '--': true
});

var fixedSrc = argv._[0] || 'src',
    fixedDest = argv._[1] || 'build';

var defaultConfig = {
  cwd: cwd,
  src: path.join(cwd, fixedSrc),
  dest: path.join(cwd, fixedDest, 'dist'),
  cache: path.join(cwd, fixedDest, 'index.json'),
  force: argv.force,
  watch: argv.watch,
  bundle: argv.bundle,
  verbose: argv.verbose,
  require: argv.require,
  server: argv.server,
  open: argv.open,
  port: argv.port,
  proxy: argv.proxy,
  browser: argv.browser,
  filtered: ['!**/_*.*']
};

if ($.isFile(pkg)) {
  $.merge(defaultConfig, $.readJSON(pkg).tarima || {});
}

if (!defaultConfig.filtered) {
  defaultConfig.filtered = [];
}

function fixedArray(obj) {
  return !Array.isArray(obj) ? obj.split(',') : obj;
}

if (argv.only) {
  var test = fixedArray(argv.only);

  defaultConfig.filtered.push(function(value) {
    for (var key in test) {
      if (value.indexOf(test[key]) > -1) {
        return true;
      }
    }
  });
}

if (argv.exclude) {
  fixedArray(argv.exclude).forEach(function(skip) {
    defaultConfig.filtered.push('!**/' + skip + '/**');
  });
}

defaultConfig.compileOptions = defaultConfig.compileOptions || {};
defaultConfig.compileOptions.globals = defaultConfig.compileOptions.globals || {};

if (argv.globals) {
  fixedArray(argv.globals).forEach(function(value) {
    var parts = value.split('=');

    defaultConfig.compileOptions.globals[parts[0]] = parts[1];
  });
}

var cmd = argv['--'],
    child;

run(defaultConfig, function(err, result) {
  // TODO: improve error handling
  if (err) {
    console.log($.style('{red|%s}', argv.verbose && err.stack || err));

    if (!argv.watch) {
      if (child) {
        child.kill();
      }

      die(1);
    }
  }

  var suffix = argv.watch ? $.style('{blackBright|[ waiting for changes... ]}') : '';

  if (!result.files.length) {
    console.log($.style('{blackBright|Without changes}'), suffix);
  } else {
    console.log($.style('{cyan|%s file(s) synced in %s}', result.files.length, $.timeDiff(result.start)), suffix);
  }

  if (cmd) {
    if (child) {
      child.kill();
    }

    var start = new Date();

    console.log($.style('> {cyan|%s} %s', cmd[0], cmd.slice(1).join(' ')));

    child = spawn(cmd[0], cmd.slice(1));
    // TODO: how to handle this output?
    // child.stdout.pipe(process.stdout);
    child.on('close', function(exitCode) {
      console.log($.style('> {cyan|%s} done in %s', cmd[0], $.timeDiff(start)));

      if (exitCode) {
        die(exitCode);
      }
    });
  }
});
