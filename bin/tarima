#!/usr/bin/env node

var path = require('path'),
    minimist = require('minimist');

var argv = minimist(process.argv.slice(2), {
  boolean: ['debug', 'force', 'watch', 'verbose', 'server', 'open'],
  string: ['map', 'only', 'exclude', 'require', 'port', 'proxy', 'browser', 'globals', 'config'],
  alias: {
    c: 'config',
    v: 'version',
    V: 'verbose',
    r: 'require',
    x: 'exclude',
    d: 'debug',
    f: 'force',
    w: 'watch',
    y: 'only',
    m: 'map',
    s: 'server',
    o: 'open',
    p: 'port',
    P: 'proxy',
    B: 'browser',
    G: 'globals'
  },
  '--': true
});

// common helpers
var $ = require('../lib/utils');

var logger = require('../lib/logger');

var die = process.exit.bind(process);

var thisPkg = require(path.join(__dirname, '../package.json'));

if (argv.help) {
  logger.writeln('USAGE:\n  ' + Object.keys(thisPkg.bin)[0] + ' [SRC] [DEST] [OPTIONS]');
  logger.writeln(function() {/*---
OPTIONS:
  -c, --config    Use configuration file
  -V, --verbose   Increase log information
  -r, --require   Load scripts at startup (e.g. -r some-module -r ./lib/hooks.js)
  -x, --exclude   Filter out sources using globs (e.g. -x test/broken -x .coffee)
                  Example patterns:
                    - *foo     -> !*foo
                    - .bar     -> !**\/*.bar
                    - x.y      -> !**\/x.y
                    - foo      -> !**\/foo/**
                    - foo/bar  -> !**\/foo\/bar/**
  -m, --map       Configure extensions mapping (e.g. -m coffee:js -m jade:hbs:html)
                  This means ".coffee to .js" and ".jade and .hbs to .html" respectively
  -y, --only      Filter out non-matching sources using String.prototype.indexOf()
  -d, --debug     Enable compileDebug flag for some engines
  -f, --force     Compile all sources always
  -w, --watch     Enable file watching for all sources
  -s, --server    Enable web-server support via BrowserSync
                  You can configure this through `serverOptions`
  -o, --open      Enable to open your default (or configured) --browser
  -p, --port      Set a different port for BrowserSync (default: 3000)
  -P, --proxy     Enable proxying instead --server (e.g. -P localhost:8080)
  -B, --browser   Set a custom browser when --open is specified
  -G, --globals   Set custom values to inject on compiled scripts (e.g. -G FOO=BAR)
---*/}.toString().match(/---([\s\S]+)---/)[1].replace(/\\/g, ''));
  die(1);
}

if (argv.version) {
  logger.printf('{cyan|⚡ %s v%s}\n', thisPkg.name, thisPkg.version);
  die(1);
}

logger.setLevel(argv.verbose ? 'verbose' : argv.debug ? 'debug' : 'info');

var run = require('../lib'),
    spawn = require('child_process').spawn;

var cwd = process.cwd(),
    pkg = path.join(cwd, 'package.json'),
    bower = path.join(cwd, 'bower.json');

var fixedSrc = argv._[0] || 'src',
    fixedDest = argv._[1] || 'build';

var defaultConfig = {
  cwd: cwd,
  src: path.join(cwd, fixedSrc),
  dest: path.join(cwd, fixedDest, 'dist'),
  cache: path.join(cwd, fixedDest, 'index.json'),
  force: argv.force,
  watch: argv.watch,
  require: argv.require,
  server: argv.server,
  open: argv.open,
  port: argv.port,
  proxy: argv.proxy,
  browser: argv.browser,
  filtered: [],
  extensions: {},
  notifications: {},
  compileOptions: {
    globals: {}
  }
};

[pkg, bower].forEach(function (file) {
  if ($.isFile(file)) {
    $.merge(defaultConfig, $.readJSON(file).tarima || {});
  }
});

if ($.isFile(argv.config)) {
  $.merge(defaultConfig, $.readJSON(argv.config) || {});
}

function fixedArray(obj) {
  return !Array.isArray(obj) ? obj.split(',') : obj;
}

function fixedValue(string) {
  if (/^-?\d+(\.\d+)?$/.test(string)) {
    return parseFloat(string);
  }

  var values = {
    true: true,
    false: false
  };

  if (typeof values[string] !== 'undefined') {
    return values[string];
  }

  return string || null;
}

if (argv.map) {
  fixedArray(argv.map).forEach(function(ext) {
    fixedArray(ext).forEach(function(map) {
      var parts = map.split(':'),
          to = parts.pop();

      parts.forEach(function(key) {
        defaultConfig.extensions[key] = to;
      });
    });
  });
}

if (argv.only) {
  var test = fixedArray(argv.only);

  defaultConfig.filtered.push(function(value) {
    value = path.relative(defaultConfig.src, value);

    for (var key in test) {
      if (value.indexOf(test[key]) > -1) {
        return true;
      }
    }
  });
}

if (argv.exclude) {
  fixedArray(argv.exclude).forEach(function(skip) {
    if (skip.indexOf('*') > -1) {
      defaultConfig.filtered.push('!' + skip);
    } else if (skip.substr(0, 1) === '.') {
      defaultConfig.filtered.push('!**/*' + skip);
    } else if (skip.indexOf('.') > -1) {
      defaultConfig.filtered.push('!**/' + skip);
    } else {
      defaultConfig.filtered.push('!**/' + skip + '/**');
    }
  });
}

if (argv.globals) {
  fixedArray(argv.globals).forEach(function(value) {
    var parts = value.split('=');

    defaultConfig.compileOptions.globals[parts[0]] = fixedValue(parts[1]);
  });
}

defaultConfig.compileOptions.compileDebug = argv.debug;
defaultConfig.compileOptions.verboseDebug = argv.verbose;

var cmd = argv['--'],
    child;

function errLog(message) {
  process.stderr.write($.color.red(message) + '\n');
}

function infoFiles(err, result) {
  if (argv.watch || argv.server) {
    logger.printf('{pending.blackBright|%s [press CTRL-C to quit]}',
      argv.watch ? 'Waiting for changes...' : 'Nothing to watch...');
  } else if (!result.files.length) {
    logger.printf('{info.blackBright|Without changes (%s)}\n', $.timeDiff(result.start));
  } else if (!(err || (result.err && result.err.length))) {
    logger.printf('{hint.greenBright|%s of %s file%s in %s}\n',
      result.ok.length,
      result.files.length,
      result.ok.length !== 1 ? 's' : '',
      $.timeDiff(result.start));
  }
}

function exec(onError) {
  if (child) {
    child.kill();
  }

  var start = new Date();

  logger.writeln($.color.cyan(cmd[0]) + ' ' + cmd.slice(1).join(' '));

  child = spawn(cmd[0], cmd.slice(1));

  child.stdout.pipe(process.stdout);

  var errors = [];

  child.stderr.on('data', function(data) {
    var line = data.toString().trim();

    if (line) {
      errors.push(line);
    }
  });

  child.on('close', function(exitCode) {
    var end = $.timeDiff(start);

    var settings = defaultConfig.notifications || {},
        message = '`' + cmd.join(' ') + '`\n— ',
        icon = settings.okIcon || path.join(__dirname, 'notify-icon.png');

    if (exitCode || errors.length) {
      icon = settings.errIcon || path.join(__dirname, 'error-notify-icon.png');
      message += 'Error';
    } else {
      message += 'Done in ' + end;
    }

    $.notify(message, settings.title || thisPkg.name, icon);

    if (errors.length) {
      errLog(errors.join('\n'));
      onError(errors.join('\n'));
    }

    logger.writeln($.color[exitCode || errors.length  ? 'red' : 'cyan'](cmd[0]) + ' done in ' + end);

    if (exitCode && !argv.watch) {
      die(exitCode);
    }
  });
}

run(defaultConfig, function(err, result) {
  if (err) {
    errLog(err.message || err.toString());
  }

  if (result) {
    infoFiles(err, result);
  }

  if (!argv.watch && err) {
    if (child) {
      child.kill();
    }

    die(1);
  }

  if (cmd.length && !err) {
    exec(this.emit.bind(null, 'error'));
  }
});
